{
  "name": "Chatapp",
  "tagline": "",
  "body": "# ChatApp\r\n\r\n<h3>Introduction</h3>\r\n\r\nWriting a chat application with popular web applications stacks like PHP has traditionally been very hard. It involves polling the server for changes, keeping track of timestamps, and it’s a lot slower than it should be.\r\n\r\nSockets have traditionally been the solution around which most realtime chat systems are architected, providing a bi-directional communication channel between a client and a server.\r\n\r\nThis means that the server can push messages to clients. Whenever you write a chat message, the idea is that the server will get it and push it to all other connected clients.\r\n\r\n<h3>The web framework</h3>\r\nThe first goal is to setup a simple HTML webpage that serves out a form and a list of messages. We’re going to use the Node.JS web framework express to this end. Make sure Node.JS is installed.\r\n\r\nFirst let’s create a package.json manifest file that describes our project. I recommend you place it in a dedicated empty directory (I’ll call mine ChatApp).\r\n\r\n<pre><code>{\r\n  \"name\": \"ChatApp\",\r\n  \"version\": \"0.0.1\",\r\n  \"description\": \"Basic Chat App with Node.js and Socket.io\",\r\n  \"dependencies\": {}\r\n}</code></pre>\r\n\r\nNow, in order to easily populate the dependencies with the things we need, we’ll use npm install --save\r\n\r\n<pre><code>npm install --save express@4.10.2</code></pre>\r\n\r\nNow that express is installed we can create an index.js file that will setup our application.\r\n\r\n<pre><code>var app = require('express')();\r\nvar http = require('http').Server(app);\r\n\r\napp.get('/', function(req, res){\r\n  res.send('&lt;h1&gt;Hello world&lt;/h1&gt;');\r\n});\r\n\r\nhttp.listen(3000, function(){\r\n  console.log('listening on *:3000');\r\n});</code></pre>\r\n\r\nThis translates into the following:\r\n\r\n1. Express initializes app to be a function handler that you can supply to an HTTP server (as seen in line 2).\r\n\r\n2. We define a route handler / that gets called when we hit our website home.\r\n\r\n3. We make the http server listen on port 3000.\r\n\r\n<h3>Serving HTML</h3>\r\nSo far in index.js we’re calling res.send and pass it a HTML string. Our code would look very confusing if we just placed our entire application’s HTML there. Instead, we’re going to create a index.html file and serve it.\r\n\r\nLet’s refactor our route handler to use sendFile instead:\r\n\r\napp.get('/', function(req, res){\r\n\r\n  res.sendFile(__dirname + '/index.html');\r\n  \r\n});\r\n\r\nAnd populate index.html with the following:\r\n\r\n<pre><code>&lt;!doctype html&gt;\r\n&lt;html&gt;\r\n  &lt;head&gt;\r\n    &lt;title&gt;Socket.IO chat&lt;/title&gt;\r\n    &lt;style&gt;\r\n      * { margin: 0; padding: 0; box-sizing: border-box; }\r\n      body { font: 13px Helvetica, Arial; }\r\n      form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }\r\n      form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }\r\n      form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }\r\n      #messages { list-style-type: none; margin: 0; padding: 0; }\r\n      #messages li { padding: 5px 10px; }\r\n      #messages li:nth-child(odd) { background: #eee; }\r\n    &lt;/style&gt;\r\n  &lt;/head&gt;\r\n  &lt;body&gt;\r\n    &lt;ul id=\"messages\"&gt;&lt;/ul&gt;\r\n    &lt;form action=\"\"&gt;\r\n      &lt;input id=\"m\" autocomplete=\"off\" /&gt;&lt;button&gt;Send&lt;/button&gt;\r\n    &lt;/form&gt;\r\n  &lt;/body&gt;\r\n&lt;/html&gt;</code></pre>\r\n\r\nIf you restart the process (by hitting Control+C and running node index again) and refresh the page.\r\n\r\n<h3>Integrating Socket.IO</h3>\r\nSocket.IO is composed of two parts:\r\n\r\n1. A server that integrates with (or mounts on) the Node.JS HTTP Server: socket.io\r\n2. A client library that loads on the browser side: socket.io-client\r\n\r\nDuring development, socket.io serves the client automatically for us, as we’ll see, so for now we only have to install one module:\r\n<pre><code>npm install --save socket.io</code></pre>\r\n\r\nThat will install the module and add the dependency to package.json. Now let’s edit index.js to add it:\r\n<pre><code>var app = require('express')();\r\nvar http = require('http').Server(app);\r\nvar io = require('socket.io')(http);\r\n\r\napp.get('/', function(req, res){\r\n  res.sendfile('index.html');\r\n});\r\n\r\nio.on('connection', function(socket){\r\n  console.log('a user connected');\r\n});\r\n\r\nhttp.listen(3000, function(){\r\n  console.log('listening on *:3000');\r\n});</code></pre>\r\n\r\nNotice that I initialize a new instance of socket.io by passing the http (the HTTP server) object. Then I listen on the connection event for incoming sockets, and I log it to the console.\r\n\r\nNow in index.html I add the following snippet before the <code>&lt;/body&gt;</code>:\r\n\r\n<pre><code>&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;\r\n&lt;script&gt;\r\n  var socket = io();\r\n&lt;/script&gt;</code></pre>\r\n\r\nThat’s all it takes to load the socket.io-client, which exposes a io global, and then connect.\r\n\r\nNotice that I’m not specifying any URL when I call io(), since it defaults to trying to connect to the host that serves the page.\r\n\r\nIf you now reload the server and the website you should see the console print “a user connected”.\r\nTry opening several tabs, and you’ll see several messages in the console.\r\n\r\nEach socket also fires a special disconnect event:\r\n<pre><code>io.on('connection', function(socket){\r\n  console.log('a user connected');\r\n  socket.on('disconnect', function(){\r\n    console.log('user disconnected');\r\n  });\r\n});</code></pre>\r\n\r\n<h3>Emitting events</h3>\r\nThe main idea behind Socket.IO is that you can send and receive any events you want, with any data you want. Any objects that can be encoded as JSON will do, and binary data is supported too.\r\n\r\nLet’s make it so that when the user types in a message, the server gets it as a chat message event. The scripts section in index.html should now look as follows:\r\n<pre><code>&lt;script src=\"/socket.io/socket.io.js\"&gt;&lt;/script&gt;\r\n&lt;script src=\"http://code.jquery.com/jquery-1.11.1.js\"&gt;&lt;/script&gt;\r\n&lt;script&gt;\r\n  var socket = io();\r\n  $('form').submit(function(){\r\n    socket.emit('chat message', $('#m').val());\r\n    $('#m').val('');\r\n    return false;\r\n  });\r\n&lt;/script&gt;</code></pre>\r\n\r\nAnd in index.js we print out the chat message event:\r\n<pre><code>io.on('connection', function(socket){\r\n  socket.on('chat message', function(msg){\r\n    console.log('message: ' + msg);\r\n  });\r\n});</code></pre>\r\n\r\n<h3>Broadcasting</h3>\r\nThe next goal is for us to emit the event from the server to the rest of the users.\r\n\r\nIn order to send an event to everyone, Socket.IO gives us the io.emit:\r\n\r\n<pre><code>io.emit('some event', { for: 'everyone' });</code></pre>\r\n\r\nIf you want to send a message to everyone except for a certain socket, we have the broadcast flag:\r\n<pre><code>io.on('connection', function(socket){\r\n  socket.broadcast.emit('hi');\r\n});</code></pre>\r\n\r\nIn this case, for the sake of simplicity we’ll send the message to everyone, including the sender.\r\n<pre><code>io.on('connection', function(socket){\r\n  socket.on('chat message', function(msg){\r\n    io.emit('chat message', msg);\r\n  });\r\n});</code></pre>\r\n\r\nAnd on the client side when we capture a chat message event we’ll include it in the page. The total client-side JavaScript code now amounts to:\r\n<pre><code>&lt;script&gt;\r\n  var socket = io();\r\n  $('form').submit(function(){\r\n    socket.emit('chat message', $('#m').val());\r\n    $('#m').val('');\r\n    return false;\r\n  });\r\n  socket.on('chat message', function(msg){\r\n    $('#messages').append($('&lt;li&gt;').text(msg));\r\n  });\r\n&lt;/script&gt;</code></pre>\r\n\r\nAnd that completes our chat application, in about 20 lines of code!\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}